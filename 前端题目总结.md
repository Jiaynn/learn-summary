#### 1.1、html标签的类型（head， body，！Doctype） 他们的作用是什么?

（1）head:<head></head>标签中的内容不会展示在浏览器中，它的作用是包含一些页面的元数据（描述数据的数据.）

head标签里面的标签作用：

title:网页的标题

base:为当前文档的所有链接设置基准链接。

meta属性里面的name是设定的关键字，当浏览器搜索到关键字时会优先排列

```
<meta charset="utf-8">
```

这个元素简单的指定了文档的字符编码 —— 在这个文档中被允许使用的字符集。 utf-8

（2）body:定义文档的主体, 包含了文档的所有内容.该标签支持 html 的全局属性和事件属性.

  (3)   !DOCTYPE 标签：它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令.

#### 1.2 h5新特性

拖拽释放(Drag and drop) API:[(55条消息) HTML5--拖拽API(含超经典例子)_冯小东的博客-CSDN博客_拖拽api](https://blog.csdn.net/baidu_25343343/article/details/53215193)

桌面通知 Notifications

离线应用 manifest

#### 1.3 伪类和伪元素

伪类和伪元素：

伪类：为已有元素在某种状态上时添加状态，这个状态是根据用户的行为来决定的

伪元素：用来创建一些不在DOM树中的元素，并为它添加状态

#### 1.4 html5语义化

语义化好处：

1.利于阅读，样式丢失的时候页面也能呈现清晰的结构

2.利于爬虫，搜索引擎根据标签来确定上下文和各个关键字的权重

3.利于开发和维护，语义化更具可读性

#### 2.1 let const var 相关

区别主要从：变量提升，暂时性死区，块级作用域，重复声明，修改声明的变量去考虑

#### 2.2 js数据类型，区别

基本数据类型：number，boolean，string，null， undfined，symbol，bigint

引用数据类型：object，function

其中object包括：普通对象，数组对象，正则对象，日期对象，Math数学函数对象。

基本数据类型存放在栈中，而引用数据类型存放在堆中

#### 2.3 Object.assign的理解

Object.assign()可以实现对象的合并    Object.assign(target, ...sources)

就是将sources里面的对象合并到target中

Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。

#### 2.4 constructor的理解

每一个对象都有一个constructor，constructor上有一个原型对象，这个原型对象指向construcor本身，如果我们修改了原来的原型对象，则必须手动利用constructor指回原来的构造函数

#### 2.5 map 和 forEach 的区别

相同点：都只能遍历数组

不同点：map有返回对象，而forEach没有

#### 2.6 for of 可以遍历哪些对象

可以遍历可迭代对象：包括Array, Map, Set, String, TypedArray, arguments对象等等

#### 2.7 js静态类型检查

js是动态语言类型

静态类型检查:在编译的时候进行检查，如果bug不修复，则编译就不会通过

动态类型检查：代码运行了一次，错误才会被发现

js进行静态类型检查的方法：FLow,TypeScript

#### 2.8 indexof

indexOf:可返回某个指定的字符串值在字符串中首次出现的位置

1、indexOf()方法对大小写敏感   2、如果要检索的字符串值没有出现，则该方法返回-1

#### 2.9 iframe有什么优点、缺点

iframe是一种框架，也是一种常见的网页嵌入方式

##### 优点：

1.它能够原封不动地把嵌入的网页展示出来

2.2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。

3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。

4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

##### 缺点：

1.会产生很多页面，不容易管理。

2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。

3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。

4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。

5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。

#### 2.10 webComponents

#### 2.11 dva的数据流流向是怎么样的

#### 2.12 变量提升

变量和函数的声明被提升到代码的最前面，变量被提升后，会被赋值为undifined

为什么会存在变量提升：因为js是单线程执行机制，执行是按顺序执行的，但是并不是逐行的分析和执行，而是一段一段地分析执行，会先进行编译阶段然后才是执行阶段。在编译阶段阶段，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为Lexical Environment的JavaScript数据结构内的内存中，所以这些变量和函数能在它们真正被声明之前使用。

#### 2.13 作用域

作用域是指程序中定义变量的区域，该位置决定了变量的生命周期。

#### 2.14 HashMap 和 Array 有什么区别？

#### 2.16 javascript中arguments相关的问题

js会把所传的参数全部存到一个叫arguments的对象里面。它是一个类数组

箭头函数中没有arguments

arguments转数组

    function test() {
      var args = Array.prototype.slice.call(arguments)
      console.log(Object.prototype.toString.call(args))
    }
    test(1, 2, 3)

es6中引入了rest参数，它表示一个未知数量的参数作为函数中的一个数组，不仅将额外的参数表示为数组，还解决了arguments对象的许多问题。

    function test(...rest) {
      console.log(rest)
    }
    test(1, 2, 3)

作用：有了arguments这个对象之后，我们可以不用给函数预先设定形参了，可以动态地通过arguments为函数加入参数

#### 2.18 数组去重

1.set()   new set(arr) ==>返回的是一个去重后的新数组

2.includes()  

let arr = ['a', 'd', 'a', 'b', 'r', 'b'];
        let newArr = [];
        //循环遍历
        for (let i = 0; i < arr.length; i++) {
            //如果新数组里的元素里不包括原数组里的元素，则把该元素放入新数组，反之舍弃
            if (!newArr.includes(arr[i])) {
                newArr.push(arr[i]);
            }
        }
console.log(newArr);

3.filter() 和includes()

let arr = ['a', 'd', 'a', 'b', 'r', 'b'];
        let newArr = [];
        newArr = arr.filter((item) => {
            return newArr.includes(item) ? '' : newArr.push(item);
        })

console.log(newArr);

#### 2.20 null 和 undefined 的区别，如何让一个属性变为null

undefined表示一个状态最原始的状态，不是人为操纵的结果

null表示一个空对象

#### 2.21 数组和伪数组的区别

伪数组只有length属性，类数组不能直接调用数组方法。

类数组==》数组

使用Array.from()

使用Array.prototype.slice.call()

#### 2.24 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

Set 是一种叫做[**集合**](http://www.javanx.cn/tag/集合/)的[数据结构](http://www.javanx.cn/tag/数据结构/)，Map 是一种叫做**字典**的数据结构

集合：是无序的，不支持下标索引，它是可变的数据类型，集合中的元素是唯一的，一般用于元组或者列表中的元素去重

字典：字典是由”键-值”（key-value）对组成的集合，字典的”值”(key)通过”键”(value)来引用。键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。

Set：他的值都是唯一的，只有键值，没有键名，类似于数组，可以遍历

set认为NaN是相等的，{}是不相等的

Map:它类似于对象，也是键值对的集合。可以遍历

WeakSet:也是不重复的值的集合。首先，WeakSet 的成员只能是对象，而不能是其他类型的值。其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

WeakMap:首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

#### 2.25 简单说说 js 中有哪几种内存泄露的情况

内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存,导致内存的浪费

原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存

实现的原理有两种情况：

1.标记清除：当这个变量进入执行环境时，就将这个变量标记为“进入环境”，，进入幻境的变量所占用的内存不能被释放，当这个变量离开环境的时候，就被标记为“离开环境”

垃圾回收程序执行的时候，会标记存储的所有变量，然后将所有在上下文中的变量和在上下文中被引用的变量去掉，然后给剩下的变量加上“待删除”的标记，随后垃圾回收处理程序再做一次内存清理，销毁带标记的所有值并回收他们的内存

2.引用计数：语言引擎里面有一张“引用表”，里面保存了内存里面所有值的引用次数，如果引用次数为0，就释放这个内存

如果一个值不再需要了，但引用次数却不为0，垃圾回收机制就无法释放内存，从而导致内存泄漏

意外的全局变量；

闭包；

未被清空的定时器；

未被销毁的事件监听；

DOM 引用

#### 2.27 json和xml数据的区别

1、json是轻量级的，传递速度更快，而xml是重量级的

2、xml在传输过程中比较占带宽，json占带宽少，易于压缩。

3、json与js的交互更加方便，更容易解析处理

4、json对数据的描述性比xml差

5、xml和json都用在项目交互下，xml多用于做配置文件，json用于数据交互。

#### 2.28 JavaScript有几种方法判断变量的类型?

#### 2.29 代码解释题

```js
var min = Math.min();
max = Math.max();
console.log(min < max);
// 写出执行结果，并解释原因
```

输出false

原因Math.min(),里面的参数是0或多个，当不传递参数时，返回infinity（无穷大），而，Math.max()不传递参数返回-infinity



![](../../%E5%9B%BE%E7%89%87/20221011-195747.jpg)



![](https://cdn.jsdelivr.net/gh/lijiayan921/Figure-bed/blob/main/image/image/202210120018370.png)
