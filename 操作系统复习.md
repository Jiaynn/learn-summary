## 操作系统复习

### 第一单元

**操作系统能做什么？**

1. 提供操作界面
2. 控制程序运行
3. 管理系统资源

**操作系统定义**

操作系统是一组控制和管理计算机软硬件资源，合理组织计算机工作流程，以及方便用户的程序合集

操作系统两大主要作用：

- 管理计算机硬件资源的程序
- 在用户和计算机硬件间的中介

操作系统是硬件设备预装的所有软件集合和内核

内核是一直运行在计算机上的程序，内核不运行则计算机无法运行

操作系统的目标：运行用户程序、更方便高效使用计算机

操作系统历史：

**手工阶段**

**批处理系统阶段**

批处理：用户将一批作业提交操作系统后就不再干预，由操作系统控制他们自动运行

单道程序设计：在内存中只存在一道作业，自动从一个运行完的作业转换到下一个作业

多道程序设计：在内存中同时存在多道作业，在管理程序之下相互穿插运行。

多道程序设计使得CPU和设备在所有时间内尽可能忙碌，提高CPU和设备利用率，充分发挥计算机系统部件的并行性

并行：两个或多个作业在同一时刻同时运行

并发：两个或多个作业在同一时间间隔内交替依次运行

特点：脱机使用，无交互性；成批处理，作业周转时间长；多道批处理具有高的资源利用率和大的吞吐量

**多道程序分时系统阶段**

分时系统是多道程序设计的延伸

一种联机的多用户交互式操作系统，采用时间片轮转方式使一台计算机为多个用户服务，在单位时间内，每个用户获得一个时间片并运行，保证用户获得足够小的响应时间，并提供交互能力

分时系统原理：

若某个作业在分配的时间片用完之前计算还未完成，该作业暂停中断，等待下一轮；此时处理机让给另一个作业使用

每个用户好像独占一台计算机（时间片小的原因）

特点：多路性、独立性、交互性、及时性

**操作系统的分类**

嵌入式系统：

完全嵌入受控器件内部。随单片机的出现而出现（智能冰箱、智能防盗门、扫地机器人等）

特点：内核小、专用性强、系统精简、高效及时

分布式系统：

支持分布式处理的软件系统，又称松耦合系统

多处理器系统：有多个紧密通信的处理器的系统，多个处理器共享计算机总线、时间、内存和外设等。并行、紧耦合系统

多核处理器系统：

一个芯片多个核，一个核即一个处理器

对称多处理：每个处理器运行操作系统的相同副本

非对称多处理：包含一个主处理器和多个从处理器，主处理器为从处理器安排任务（适用于手机）

集群系统：

通过专用网络连接一群计算机，把这些计算机虚拟化为一台有超强计算能力的计算机给用户使用。采用并行化编程技术

**操作系统功能**

**进程管理**

操作系统核心目标是运行程序，进程是运行中的程序

CPU/进程管理：对CPU进行管理

程序运行中的问题：

软件错误或特定请求产生异常或陷阱/其他进程问题：死循环等

解决方法：双重模式（用户模式和内核模式），特权指令：可能引起系统崩溃的指令，只能运行在内核模式

用户程序需要特权指令：通过系统调用

如果操作系统不能获得CPU控制权，就无法管理系统，当用户程序出现死循环等

通过定时器来解决，在一段时间后发生中断，CPU控制权返回操作系统

**内存管理**

内存器—地址空间

物理地址空间：内存中的一系列单元所限定的地址范围

逻辑地址空间：用户程序经过编译后形成若干目标程序，这些目标程序经过连接形成可装入程序。这些程序的地址都是从‘0’开始，程序中其他地址相对于该起始地址计算，这些地址所形成的地址范围即为逻辑地址空间。

线性地址空间：逻辑地址到物理地址转换之间的中间层，是处理器可寻址的内存空间中的地址。线性地址空间是逻辑上的内存空间，实际并不存在

线性地址空间的作用是将用户与实际物理内存隔离，通过操作系统来管理物理内存，使得内存操作更安全。

访问没有与物理地址建立映射的线性地址是非法的

虚拟内存：操作系统可以把部分地址装入内存，部分留在磁盘上。它使得应用程序认为他拥有连续的可用的内存，而实际上，它通常被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230207194724928.png" alt="image-20230207194724928" style="zoom: 67%;" />

内存管理：提供内存的分配、回收、地址转换、共享和保护等功能

提高内存利用率、提高内存访问速度，进而提高计算机运行效率

**文件管理**

解决信息在计算机中存储问题，以文件为单位，以目录为组织方式构建文件系统

**I/O设备管理**

管理种类繁多的各种I/O设备，解决计算机中信息的输入和输出问题

I/O设备包括设备控制器和设备本身

设备控制器：插在电路板上的一块或一组芯片，负责从操作系统接受命令

设备驱动程序：专门与设备控制器对话，发出命令并接受响应的软件，绝大多数设备驱动器在系统内核态运行

中断：当出现需要时，CPU暂时停止当前程序的执行，转而执行处理新情况的程序和执行过程

中断号：外部设备进行I/O操作时产生的中断信号，发送给CPU

中断向量：中断服务程序的入口地址

中断服务程序：执行中断处理的代码

操作系统是中断驱动

**系统启动**

系统启动就是将操作系统读入内存的工作

实模式：x86是32位的CPU,所以无法运行早期16位的汇编程序，为了能运行16位的程序，这种方式就叫做实模式，计算机启动的时候，是从实模式开始启动的

保护模式：支持多个任务，每个任务都有自己的内存，互不干扰，可以理解为多进程

实模式和保护模式最大的区别是寻址大小的区别

对于32位的计算机，实模式和保护模式的寻址大小各为多少？

实模式：地址总线为20位，这样它能寻址的能力其实是2 ^ 20 = 1MB

保护模式：寻址模式将地址空间扩展到整个32bit，最大寻址4Gb

系统启动过程：

- 启动BIOS
- 准备实模式下的中断向量表和中断服务程序
- 加载操作系统内核程序并为保护模式做准备
- 进行保护模式，为main函数调用做准备
- 内核初始化
- 生成init进程
- 系统初始化，shell命令文本执行
- 生成各终端进程

fork是复制进程的函数，程序一开始会产生一个进程，执行fork，会复制一份原来的进程即创建一个新进程，我们称为子进程，原来的进程叫做父进程

守护进程是一个在后台运行且不受任何终端控制的进程，他们在后台运行，执行不同的管理任务。独立于所有终端，大多数在系统引导的时候启动并且一直运行到系统关闭。

守护进程本质是一个孤儿进程，后台运行且不拥有控制终端，大多都在内核态运行

**进程**是系统进行资源分配和调度的基本单位

进程由程序段、数据段、程序控制块（PCB）组成

PCB是操作系统对进程进行控制与管理的唯一方式，是一种存放了进程相关信息的数据结构

程序段：程序代码存放的位置

数据段：程序运行时使用、产生的运算数据

UID：每一个被启动的进程都有一个启动该进程的用户UID, 子进程和父进程拥有一样的UID

**死锁**

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或由于彼此通信而造成的一种堵塞现象，若无外力作用，他们都将无法推进下去。这些永远在互相等待的进程称为死锁进程。多个进程互相需要对方资源，然后形成僵持。

**文件系统**

操作系统需要隐藏磁盘和其他I/O设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型

文件系统是软件系统的一部分，它使得应用可以方便的使用抽象命名的数据对象和大小可变的空间

- 文件
- 文件控制块
- 目录
- 目录文件

管道：连接两个进程的虚文件，进程间通过读写管道进行对话和数据交互

**用户接口**

- 命令接口、图形用户接口：提供给用户命令的方式控制系统运行/为用户提供图形化的操作界面
- 系统程序：用于管理、维护操作系统的程序
- 系统调用（程序接口）：用户程序使用该接口访问系统资源，从而获取操作系统服务

Shell是UNIX的命令解释器，同时也是终端用户与操作系统之间的接口，用户登录时会同时启动一个shell，他以终端为标准输入输出

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230207200327245.png" alt="image-20230207200327245" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230207200451585.png" alt="image-20230207200451585" style="zoom:67%;" />

**操作系统结构**

**层次结构**：操作系统划分为若干层，在低层上构建高层，底层（0层为硬件），最高层（N层为用户层），每层只使用低层次的功能和服务，各层之间只能单向依赖

**微内核结构**

问题：内核越来越多，越来越难管理

内核微型化：核内移除尽可能多功能到用户空间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230207202551830.png" alt="image-20230207202551830" style="zoom:50%;" />

微内核设计的优点：

- 便于扩充微内核
- 便于移植操作系统到新架构系统上
- 更稳定、更安全

缺点：

用户空间和内核空间通信的系统开销增加

解决方法：提出消息传递机制

**模块结构**

大部分操作系统采用的是模块结构

- 使用面向对象方法
- 每个核心部件分开
- 每个与其他模块的会话称为接口
- 每个模块在需要时被加载到内核

模块之间可以任意调用，有利于系统设计和扩展

模块之间存在复杂依赖关系，使得OS结构不清晰

**虚拟机**分为第一类虚拟机和第二类虚拟机，第一类没有底层支持，必须自行实现所有功能，工作站虚拟机属于第二类，服务器虚拟机属于第一类

**内核态和用户态**

内核态：运行操作系统程序，操作硬件

用户态：运行用户程序

区别

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。**因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；**
- 当程序运行在0级特权级上时，就可以称之为运行在内核态。
- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
- 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

**用户态--->内核态：**唯一途径是通过中断、异常、陷入机制（访管指令）

**内核态--->用户态：**设置程序状态字PSW

### 第二章—进程

程序

程序顺序执行：程序是指令的集合，即指令序列，是静态的，它具有顺序性，封闭性，可在线性

多道程序执行系统中程序的执行：独立性、随机性、资源共享

并发执行的程序：随机性，失去了顺序执行了封闭性和可再现性（解决方案：核心顺序执行部分加锁）

进程：正在执行的程序，是**一个程序**在**一个数据集合**上的**一次运行活动**

进程特点：动态性、并发性、独立性、异步性

进程 VS 程序

1. 进程是动态的，程序是静态的
2. 进程在内存，程序在外存
3. 进程可以并发，而程序不行
4. 进程是资源竞争的基本单位
5. 一个程序可以对应一个或多个进程
6. 进程是程序的一个实例，是程序的一次执行
7. 程序是进程的代码部分

子进程在撤销时应该归还资源给父进程

撤销父进程时，应该撤销所有的子进程

进程不能拒绝子进程的继承权

**进程在内存中的存储**

栈：由编译器自动分配释放，存放函数的参数值、局部变量等

堆：由程序员手动分配释放；若不释放，在程序结束时可能由OS回收

未初始化数据

初始化数据

代码区

**进程的状态及转换**

就绪态：获取了除CPU之外的所有资源的进程状态，只要获得了CPU就可以立即执行

运行态：已经获得了CPU，程序正处于执行状态

阻塞态：由于发生某事件（如I/O请求，申请缓冲区失败），暂时无法继续执行的状态，即进程的执行受到阻塞

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208092021230.png" alt="image-20230208092021230" style="zoom:80%;" />

进程的创建：

1. 进程申请一个空白的PCB，向 PCB 写入管理和控制进程的信息
2. 为该进程分配运行时所需要的资源
3. 把进程转为就绪态，并插入到就绪队列中

创建态：如果进程所需要的资源尚不能得大满足，此时创建工作尚未完成，进程不能被调度，处于创建态

进程的终止：

1. 等待操作系统相应的善后处理
2. 将PCB清零并将其占用空间返还系统

终止态：当进程到达了自然结束点 / 出现了无法克服的错误 / 被操作系统终结 / 被其他具有终止权限的进程终结

程序进入到终止态后

1. 处于终止态的程序不再执行
2. 系统保留一个记录供其他进程收集
3. 其他进程完成信息收集后，操作系统删除该进程

**进程的挂起与状态转换**

进程被挂起时，意味着进程处于静止状态

- 如果进程正在执行，他将暂停执行
- 如果进程处于就绪状态，他将暂时不接受调度

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208093242447.png" alt="image-20230208093242447" style="zoom:80%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208093350535.png" alt="image-20230208093350535" style="zoom:80%;" />

进程控制块 PCB 作用

1. 作为独立运行基本单位的标志：系统通过PCB感知进程的存在。PCB是进程存在于系统的唯一标识
2. 能实现间断性运行方式：在中断和阻塞时，系统通过PCB保留和恢复CPU现场信息。PCB作为保护和保存程序运行现场的手段，确保了运行结果的可再现性
3. 提供进程管理所需要的信息：根据PCB可以知道该进程所需的全部信息，在进程的生命周期中，操作系统根据PCB对进程进行管理和控制
4. 提供进程调度所需要的信息：只有处于就绪态的进程才能被调度，而PCB提供了进程处于何种状态的信息
5. 实现与其他进程的同步与通信：进程同步机制是用于实现进程的协调运行的，PCB中含有用户进程通信的区域或通信队列指针等

PCB包含的信息：进程描述信息、进程控制信息、资源信息、CPU现场信息

进程标识符：用于唯一的标识一个进程

处理器状态

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208094833373.png" alt="image-20230208094833373" style="zoom:67%;" />

进程的调度信息：进程调度所必须的信息

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208094909329.png" alt="image-20230208094909329" style="zoom:67%;" />

进程的控制信息：进程控制所必须的信息

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230208095007381.png" alt="image-20230208095007381" style="zoom:80%;" />

进程在内核态运行时需要自己的堆栈信息，因此linux为每个进程都提供了一个内核栈

用户态进程所用的栈，是在进程线性地址空间

当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，那么内核空间中使用的就是内核栈

**进程控制块的组织方式**

链表：同一个状态的进程其PCB成一链表，多个状态对应多个链表；各状态的进程形成不同的链表：就绪链表、阻塞链表

索引表：同一个状体的进程归入一个索引表（由索引指向PCB）,多个状态对应多个不同的索引表

![image-20230209091240806](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209091240806.png)

**状态队列**

由操作系统来维护一组队列，表示系统中所有进程当前的状态

不同队列表示不同的状态

根据进程状态不同，进程PCB会加入相应的队列（进程状态变化时，他所在的PCB会从一个队列换到另一个）

系统使用具有特定功能的程序段来创建、撤销进程及完成进程之间的状态转换

原语：（原子操作）系统下执行的某些具有特定功能的程序段

- 机器级指令：不允许中断
- 功能级：不允许并发执行

用于进程控制的原语：创建、撤销、阻塞、唤醒原语

fork()

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209092536864.png" alt="image-20230209092536864" style="zoom:80%;" />

exec()：通过一系列系统调用，他们都是通过用**一段新的程序代码覆盖原来的地址空间**，实现进程执行代码的转换

wait(): 提供初级进程同步操作，能使一个进程等待另一个进程的结束

exit(): 用来终止一个进程的运行

上下文切换：将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换

进程运行时，其硬件状态保存在CPU上的寄存器中

进程不运行时，这些寄存器的值保存在进程控制块中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中

线程是进程的一部分，描述指令流执行状态。他是进程中**指令流的最小单位**，是CPU**调度**的基本单位

线程：线程是调度的基本单位

线程的优点：

- 一个进程中可以同时存在多个线程
- 各个线程之间可以并发的执行
- 各个线程之间可以共享共享地址空间和文件等资源

线程的缺点：

- 多个线程抢夺一个资源可能造成线程不安全
- 一个线程崩溃，可能会导致其所属进程的所有线程崩溃

进程是资源分配的单位，线程是CPU调度的单位

进程拥有一个完整的资源平台，而线程**只独享指令流执行的必要资源**，如寄存器和栈

线程能减少并发执行的时间和空间开销

**用户线程的实现**（在用户空间实现）

由一组**用户级的线程库函数**来完成线程的管理，包括线程的创建、终止、同步和调度等

用户线程的特点

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209184636329.png" alt="image-20230209184636329" style="zoom:67%;" />

用户线程的不足：

- 线程发起系统调度而阻塞时，则整个进程进入等待
- 不支持基于线程的处理机抢占（除非当前运行线程主动放弃，他所在的进程的其他线程无法抢占CPU）
- 只能按进程分配CPU时间（在多线程进程中，每个线程分配的时间片较少）
- 内核只将处理器分配给进程

**内核线程的实现**（在内核中实现）

由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理

内核线程的特点：

- 由内核维护PCB和TCB
- 线程执行系统调用阻塞不影响其他线程
- 线程的创建、终止和切换相对较大
- 以线程为单位分配CPU时间

**轻量级线程的实现**（在内核中实现，支持用户线程）

**内核支持的用户线程**。一个进程可以有一个或多个轻量级的进程，每个轻权进程由一个单独的内核线程来支持（用户态创建，内核态调度）

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209185209060.png" alt="image-20230209185209060" style="zoom:67%;" />

多对一

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209185434220.png" alt="image-20230209185434220" style="zoom:67%;" />

一对一

- 用于支持线程的操作系统（用户线程映射到内核线程、操作系统管理这些线程）
- 并发性好：多个线程可以并行运行在多个处理器上
- 内核开销大

多对多

多个用户线程映射为相等或更小数目的内核线程（并发性和效率兼顾、增加复杂度）

**进程的并发执行**

- 并发是所有问题产生的根源
- 并发是操作系统设计的基础

进程之间的制约

![image-20230209190142571](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209190142571.png)

**进程同步**

指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务

定义：异步环境下，一组并发进程因直接制约而相互发送消息，相互合作，相互等待，使各进程按一定速度执行的过程

具体来说就是一个进程运行到某一点时，要求另一个伙伴进程为他提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209190843587.png" alt="image-20230209190843587" style="zoom: 67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230209190902076.png" alt="image-20230209190902076" style="zoom: 67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210085744185.png" alt="image-20230210085744185" style="zoom:67%;" />

**进程互斥**

两个或多个进程读取某些共享数据时，最后的结果取决于进程运行的精确时序

互斥：不允许两个以上共享该资源的并发进程同时进入临界区

**临界资源**：系统中某些资源一次只允许一个进程使用

**临界区**：各个进程中对某个临界资源实施操作的程序片段

**空闲让进**：没有进程在临界区时，想进入临界区的进程可进入

**忙则等待**：不允许两个进程同时处于临界区中

**让权等待**：临界区运行的进程不得阻塞其他进程进入临界区，当进程不能自己进入临界区时，应当释放

**有限等待**：保证在有限时间内进入临界区，不得陷入无限期等待

**进程通信**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210092759879.png" alt="image-20230210092759879" style="zoom:67%;" />

**关中断法**：每个进程进入临界区后先关中断，离开前开中断

优缺点：简单高效、代价高，限制CPU并发能力、不适用于多处理器、适用于操作系统本身，不适用于用户进程

**加锁法**：用锁变量来表示临界区是否可用

缺点：CPU费时、存在不公平现象

**严格的轮转法**：用标志严格控制轮流使用临界区

缺点：当一个进程比另一个进程慢很多时不好

**信号量**：信号量是操作系统提供的一种协调共享资源访问的方法

- 软件同步是平等线程间的一种同步协商机制
- 用信号量表示系统资源的数量
- OS是管理者，地位高于进程

**Peterson算法**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210092840008.png" alt="image-20230210092840008" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210092856913.png" alt="image-20230210092856913" style="zoom:67%;" />

**Dekkers算法**

两个全局共享的状态变量flag[0]和flag[1]，表示临界区状态及哪个进程想要占用临界区，初始值为0。

全局共享变量turn（值为1或0）表示能进入临界区的进程序号，初始值任意，一般为0。

```c
1）P0的逻辑

do{
flag[0] = true;// 首先P0举手示意我要访问
while(flag[1]) {// 看看P1是否也举手了
if(turn==1){// 如果P1也举手了，那么就看看到底轮到谁
flag[0]=false;// 如果确实轮到P1，那么P0先把手放下（让P1先）
while(turn==1);// 只要还是P1的时间，P0就不举手，一直等
flag[0]=true;// 等到P1用完了（轮到P0了），P0再举手
}
}
visit();// 访问临界区
turn = 1;// P0访问完了，把轮次交给P1，让P1可以访问
flag[0]=false;// P0放下手
```

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210093047833.png" alt="image-20230210093047833" style="zoom:50%;" />

基于软件的解决办法：复杂（需要两个进程间的共享数据项）、需要忙等待（浪费CPU时间）

**更高级的抽象方法**

硬件提供了一些同步原语（中断禁用，原子操作指令等）

操作系统提供更高级的编程抽象来简化进程同步

- 例如：锁、信号量
- 用硬件原语来构建

**锁lock**

- 锁是一个抽象的数据结构
  - 一个二进制变量（锁定/解锁）
  - Lock::Acquire()
    - 锁被释放前一直等待，然后得到锁
  - Lock::Release()
    - 释放锁，唤醒任何等待的进程

原子操作指令

Test and set指令；**把给定的内存地址设置为1，然后返回之前的旧值。**

```c
boolean test-and-set(*lock)
{
    boolean old=*lock;
    *lock=true;
    return old;
 
}
```

交换指令

```c
void exchange（boolean *a,boolean *b）{
boolean temp=*a
*a=*b
*b=temp
}
```

自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为`自旋锁(spinlock)`。

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210100319803.png" alt="image-20230210100319803" style="zoom:67%;" />

如果锁处于忙状态，就会一直处于忙等待状态

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210100717688.png" alt="image-20230210100717688" style="zoom:67%;" />

原子操作指令锁的特征

优点：

- 适用于单处理器或者共享主存的多处理器中任意数量的进程同步
- 简单容易证明
- 支持多临界区

缺点：

忙等待消耗处理器时间

可能导致饥饿（进程离开临界区时有多个等待进程的情况）

死锁：拥有临界区的低优先级进程请求访问临界区高优先级进程获得处理器并等待临界区

**信号量**

信号量是一种抽象数据类型

由一个整形（sem）变量和两个原子操作组成，P是请求资源，V是释放资源

信号量：是OS中表示资源的物理实体，是一个与队列相关的整形变量，其值仅由down，up原语改变

信号量的表示意义：

设s为信号量，则：

当s>=0，表示可供并发进程使用的资源实体数

当s<0，表示正在等待使用资源的进程数

信号量是被保护的整数变量

- 初始化完成后，只能通过P()和V()操作修改
- 由操作系统保证,PV操作是原子操作

P()可能阻塞，V()不可能阻塞

**信号量实现**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210102243647.png" alt="image-20230210102243647" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210102257988.png" alt="image-20230210102257988" style="zoom:67%;" />

信号量可分为两种信号量

- 二进制信号量：资源数目为0或1
- 资源信号量：资源数目为任何非负值

信号量的使用

- 互斥访问：临界区的互斥访问控制
- 条件同步：线程间的时间等待

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210102837899.png" alt="image-20230210102837899" style="zoom:67%;" />



<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210102853218.png" alt="image-20230210102853218" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210103038842.png" alt="image-20230210103038842" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210103057389.png" alt="image-20230210103057389" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230210103127669.png" alt="image-20230210103127669" style="zoom:67%;" />

同步方法总结：

锁是一种高级的同步抽象方法

- 互斥可以使用锁来实现
- 需要硬件支持

常用的三种同步实现方法

- 禁用中断（仅限于单处理器）
- 软件方法
- 原子操作指令（单处理或多处理器均可）

使用信号量的困难

- 读/开发代码比较困难（程序员需要能运用信号量机制）
- 容易出错（使用的信号量已经被另一个线程占用、忘记释放信号量）
- 不能处理死锁问题

**引入 “管程”**

每个访问临界资源的进程都需要自备同步操作wait(S)和signal(S)，存在大量同步操作容易造成死锁—>在程序语言中引入管程成分，一种高级的同步机制

- 管程是一个特殊的模块，有一个名字
- 关于共享资源的数据结构 以及在其上操作的一组过程

进程只能通过调用**管程中的过程**来间接的访问管程中的数据结构

一个锁（控制管程代码的互斥访问）

0或多个条件变量（管理共享数据的并发访问）

**管程是一种用于多线程互斥访问共享资源的程序结构**

- 采用面向对象方法，简化了线程间的同步控制
- 任一时刻最多只有一个线程执行管程代码
- 正在管程中线程可临时放弃管程的互斥访问，等待事件出现时恢复

**管程的使用**

- 在对象/模块中，收集相关共享数据
- 定义访问共享数据的方法

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211103645023.png" alt="image-20230211103645023" style="zoom:50%;" />

管程时一种跟高级的同步原语，更便于使用，管程的互斥由**编译器负责**，使用者只需将所有**临界区转换为管程即可**

一个管程是由过程、条件变量、数据结构等组成的特殊模块或软件包，进程仅能通过管程访问其中的数据结构

管程的特性：**任一时刻管程中只能有一个活跃进程**

**基本通信方式**

消息传递、管道、共享内存、套接字、远程过程调用

**消息传递**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211104629020.png" alt="image-20230211104629020" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211104606965.png" alt="image-20230211104606965" style="zoom:50%;" />

**管道通信**

利用一个缓冲传输介质—内存或文件 连接两个相互通信的进程

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211104759502.png" alt="image-20230211104759502" style="zoom:50%;" />

**共享内存**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211104928259.png" alt="image-20230211104928259" style="zoom:50%;" />

- 进程IPC机制的一种，用于快速的交换大量数据
- 每个进程需要讲创建的共享内存空间映射到自己的徐空间
- 多个进程对于共享内存的访问需互斥

基本原理：允许一个或多个进程通过同时出现在他们的虚拟地址空间的内存进行通信。改虚拟内存页面在每一个共享进程的页表都有页表条目引用

**进程调度**

处理机资源的使用模式

进程在CPU计算和I/O操作间交替

- 每次调度决定在下一个CPU计算时将哪个工作交给CPU
- 在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU

**CPU资源的时分复用**

进程切换：CPU资源 的 当前占用者 切换

- 保存当前进程在PCB中的执行上下文
- 恢复下一个进程的执行上下文

处理机调度

- 从就绪队列中**挑选**下一个占用CPU运行的**进程**
- 从多个可用CPU中**挑选**就绪进程可使用的CPU**资源**

调度程序是 挑选就绪进程的**内核函数**

**非抢占系统**：当前进程主动放弃CPU时

**可抢占系统**

- 中断请求被服务例程响应完成时
- 当前进程被抢占（进程时间片用完、进程从等待切换到就绪）

**调度策略**

调度策略：确定如何从就绪队列中选择下一个执行进程

低级调度：又称进程调度，短程调度，决定哪个进程占有CPU

中级调度：平衡/中程调度，决定哪个进程挂起，或重新调回；平衡系统负载，提高内存利用率，系统吞吐量

高级调度：又称作业、长程调度，选定作业进入主内存，为其创建进程，作业完成之后的善后工作

**CPU调度**

what: 按什么原则选择下一个要执行的进程（调度算法）

when: 何时选择（调度时机）

how: 如何让被选中的进程上CPU运行（调度过程，进程的上下文切换）

进程调度的本质是进程上下文切换

进程调度的时机

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211112618183.png" alt="image-20230211112618183" style="zoom:50%;" />

进程上下文切换

- 进程调度程序从就绪队列选择了要运行的进程
- 这个进程可以是刚刚被暂停执行的进程，也可以是另一个新的进程

进程切换是指一个进程让出处理器，由另一个进程占用处理器的过程

进程切换的步骤

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211112839340.png" alt="image-20230211112839340" style="zoom:50%;" />

切换过程包括了对原来运行进程的各种状体啊保存和对新进程的各种状态恢复

调度方式

可剥夺式调度：强行剥夺先行进程的CPU周期，分配CPU给另一进程

不可剥夺式调度：进程一直执行下去，直到完成本次CPU执行周期

**CPU周期：进程在CPU上一次连续执行的过程**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211113131407.png" alt="image-20230211113131407" style="zoom:50%;" />

作业调度目标：公平、高效、大吞吐量、短的响应时间和周转时间

**CPU利用率=CPU有效工作时间/CPU总的工作时间**

平均周转时间：完成的时间-进入的时间  

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211154329396.png" alt="image-20230211154329396" style="zoom:50%;" />

平均带权周转时间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211153109473.png" alt="image-20230211153109473" style="zoom:50%;" />

平均等待时间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211153126271.png" alt="image-20230211153126271" style="zoom:50%;" />

**先来先服务算法**（FCFS）

依据进程进入就绪状态的先后顺序排列（进程进入等待或结束状态时，就绪队列中的下一个进程占用CPU）

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211165047469.png" alt="image-20230211165047469" style="zoom:50%;" />

优点：简单

缺点：

- 平均等待时间波动较大（短进程可能排在长进程后面）
- I/O资源和CPU资源的利用率较低（CPU密集型进程会导致I/O设备闲置、I/O密集型进程也等待）

**短进程优先算法**（SPN）

选择就绪队列中执行时间最短进程占用CPU进入运行状态

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211165400027.png" alt="image-20230211165400027" style="zoom:50%;" />

缺点：

- 可能导致饥饿（连续的短进程流会使长进程无法获得CPU资源）
- 需要预知未来
  - 如何预估下一个CPU计算的持续时间？
  - 简单的解决办法：询问用户
  - 用户欺骗就杀死相应进程
  - 用户不知道怎么办？

**最高响应比优先算法（HRRN）**

选择就绪队列中响应比R最高的进程

R= (w+s)/s     w: 等待时间，s: 执行时间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211170744027.png" alt="image-20230211170744027" style="zoom:50%;" />

**时间片轮转算法**

将CPU时间划分成多个时间片，每个进程使用一个时间片

算法思路：

- 时间片结束时，按FCFS算法切换到下一个就绪进程
- 每隔（n-1）个时间片进程执行下一个时间片q

为短任务改善平均响应时间

优缺点

- 公平
- 有利于交互式计算，响应时间快
- 由于进程切换，时间片轮转算法要花费较高的开销

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230211171438827.png" alt="image-20230211171438827" style="zoom:50%;" />

**优先级调度算法**

选择优先级高的进程/作业执行

**优先级设置方式**

- 静态：创建时由系统为其确定，一旦设定就不变化
- 动态：由运行环境及其自身特性的变化而改变优先级

确定静态优先级的静态特性：

- 进程类型：（系统，用户）
- 作业要求资源

确定动态优先级的动态特性：

- 进程已有CPU时间长短
- 进程在就绪队列中等待时间长短

**死锁**

死锁：是指两个或两个以上的进程在执行过程中，由于**竞争资源**或由于彼此通信而造成的一种堵塞现象，若无外力作用，他们都将无法推进下去。这些永远在互相等待的进程称为死锁进程。多个进程互相需要对方资源，然后形成僵持。

如果在一个进程集合中的每个进程都在等待只能由该集合的另一个进程引发的事件，该组进程就被死锁

死锁产生的原因：

竞争资源的特性、进程推进顺序非法

产生死锁的四个必要条件

互斥、请求和保持、不可剥夺、环路等待条件

**互斥**

死锁涉及到的资源，仅能被一个进程使用，并且该资源不能被多个进程共享使用

**请求和保持条件**

一个进程必须至少保持一个分配的资源，同时等待其他一个或者多个资源，但这些资源已经被其他进程占有

**不可剥夺条件**

进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放

**循环等待条件**

若干进程之间形成一种头尾相连的循环等待资源关系

处理死锁的四种策略

1. 忽略该问题
2. 检测并恢复（允许死锁发生，然后检测他们，再采取行动）
3. 通过仔细的资源分配来动态的避免死锁
4. 通过结构上破坏死锁的四个必要条件来预防死锁

可剥夺资源：可以从拥有他的进程剥夺而不会产生副作用（存储器就是一类可剥夺资源）

不可剥夺资源：无法在不导致计算机失败的情况下从其拥有者中剥夺（CD刻录机在任何时刻都是不可剥夺的）

**从死锁中恢复**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230213093111468.png" alt="image-20230213093111468" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230213093143846.png" alt="image-20230213093143846" style="zoom:67%;" />

**死锁避免**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230213093258710.png" alt="image-20230213093258710" style="zoom:67%;" />

避免死锁的主要算法基于安全状态的概念

避免死锁的方法是：

- 将系统的状态划分为安全状态和不安全状态，通过施加一些较弱的限制条件，使得系统始终都处于安全状态
- 允许进程动态的申请资源，但在分配资源之前要对系统的安全状态进行判定，若分配的操作是安全的，则分配；否则不予分配

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230213093751836.png" alt="image-20230213093751836" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230213093902079.png" alt="image-20230213093902079" style="zoom:67%;" />

安全状态一定没有死锁发生

银行家算法

**第四章 存储管理**

存储管理程序处理存储器层次

他的任务

- 记录哪些内存在使用，哪些内存是空闲的
- 在进程需要时为其分配存储空间，在进程使用完毕后释放存储空间
- 当内存无法装入所有进程时，管理内存和磁盘间的交换

存储管理器功能：

- 内存空间管理
- 内存的分配与回收
- 地址映射（重定位）
- 存储保护
- 处理内存超载

单道程序：每个程序直接访问物理内存，内存不能同时运行两个程序

**无内存抽象的多道程序**

- 使用交换技术：把当前内存中的所有内容保存到磁盘文件中，把下一个程序读入内存运行。保证某一时间内存中只有一个程序
- 使用硬件帮助—保护键，利用保护键防止进程间相互干扰
- **静态重定位技术：**当用户程序加载到内存时，一次实现逻辑地址到物理地址的转换

实现多道程序最简单的方法是直接把内存划分为n个分区

当一个作业到达时，可以放到能容纳他的最小分区的输入队列中，分区的大小是固定的，没有被作业使用的分区空间就浪费了

**无存储器抽象**

本质是把物理地址完全暴露给用户进程

存在问题：

- 用户程序可能会破坏操作系统
- 多道程序设计很困难

**地址空间：**一个进程可用于寻址内存的一套地址集合

每个进程都有一个自己的地址空间。并且独立于其他进程的地址空间

地址空间：源程序经过编译后目标程序所在的一个地址范围（逻辑地址）

存储空间：内存中的物理存储单元的集合（物理地址）

一种简单实现：动态重定位

硬件支持：基址寄存器和界限寄存器

重定位：逻辑地址到物理地址的映射

静态重定位

当程序载入内存时直接修改指令，例如载入分区1 的程序，在每个地址上加100K。其中，链接程序必须在产生的二进制代码程序中包含列表或位映像；

动态重定位

基址寄存器：程序的起始物理地址

界限寄存器：程序的长度

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214093421621.png" alt="image-20230214093421621" style="zoom:67%;" />

**内存管理**

分配内存时，操作系统必须对其进行管理

**位图**：内存被划分为**一定大小**的分配单元，每个单元对应位图中的一位

特点：

- 位图占用内存空间
- 分配单元的大小和位图的大小权衡困难
- 位图的搜索耗时

**使用位图的存储管理**

使用位图：内存被划分成分配单元，可能小到几个字，也有可能大到几千字节。每个分配单元对应位图中的一位，0表示空闲，1表示占用

内存分配：把一个占有K个分配单元的进程调如内存时，存储管理器搜索位图，在位图中找出有K个连续0的串

分配的单元越小，位图越大；位图提供了一种简单的方法来记录固定容量的内存字，因为位图的大小只依赖于内存和分配单元的大小

缺点：查找位图中指定长度的连续0串是耗时的操作

**使用链表的存储管理**

使用链表：维护一个 记录已分配和空闲内存段的链表，其中，段是指一个进程或两个进程间的空闲区

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214094841626.png" alt="image-20230214094841626" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214095825592.png" alt="image-20230214095825592" style="zoom:67%;" />

内存分配方式：连续分配和离散分配

连续分配：单一连续分配、固定分区分配、动态分区分配

离散分配：分页、分段、段页

固定分区分配：内存用户空间划分为若干个固定大小的区域，在每个分区装入一道作业

动态分区分配：分区位置和大小都不固定，应作业的要求而设置，动态分配内存空间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214100531724.png" alt="image-20230214100531724" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214100732571.png" alt="image-20230214100732571" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214100846655.png" alt="image-20230214100846655" style="zoom:67%;" />

**最先匹配策略**

思路：分配n个字节，使用第一个可用空间比n大的空闲块

原理&实现：

- 空闲分区列表按顺序按地址顺序排序
- 分配过程时，搜索一个合适的分区
- 释放分区时，检查释放可与临近分区合并

优点：简单、在高地址有大块的空闲分区

缺点：外部碎片、分配大块时较慢

**下次匹配策略**

原理&实现

对首次适配算法进行调整，记录上一次搜索停止位置，下一次搜索从这里开始

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214101624260.png" alt="image-20230214101624260" style="zoom:67%;" />

**最佳匹配策略**

思路：分配n字节分区时，查找并使用不小于n的最小空闲分区

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214101800499.png" alt="image-20230214101800499" style="zoom:67%;" />

**最差匹配策略**

思路：分配n字节，使用尺寸不小于n的最大空闲分区

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214101921175.png" alt="image-20230214101921175" style="zoom:67%;" />

**虚拟内存：处理内存超载最重要的技术**

程序规模增长速度远远大于存储器容量的增长速度

基本思想：每个进程拥有自己的地址空间，这个空间被分割成多个大小相等的块，每一块称作页或者页面，让部分页面进驻内存也能顺利完成

硬件基础：磁盘，所有页面在磁盘有副本

理论基础：程序执行的局部性原理

技术基础：离散内存分配，即进程的**逻辑地址空间**内分散的存储在内存**不连续的物理地址空间**中，典型技术—分页/分段/段页式

**虚拟存储的基本概念**

思路：将不常用的部分内存暂存到外存

原理：

- 装载程序时，只将当前指令执行需要的部分页面或段装入内存
- 指令执行中需要的指令或数据不在内存（称为缺页或缺段）时，处理器通知操作系统将相应的页面或段调入到内存
- 操作系统将内存中暂时不用的页面或段保存到外存

实现的方式：

虚拟页式存储、虚拟段式存储

**覆盖于交换的比较**

![image-20230214192534627](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214192534627.png)

局部性原理

程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域，有时间局部性、空间局部性、分支局部性

虚拟存储技术的目标

只把部分程序放到内存中，从而运行比物理内存大的程序

实现进程在内存与外存之间的交换，从而获得更多空闲的内存空间

**虚拟存储的支持技术**

硬件：MMU     操作系统：页面置换算法

![image-20230214201258054](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201258054.png)

页表结构，叶表给出虚拟地址与物理地址之间的映射关系，内存管理单元MMU完成地址映射

![image-20230214201321403](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201321403.png)

页式存储管理

页帧：把物理地址空间划分为大小相同的基本分配单位

页面：把逻辑地址空间划分为大小相同的基本分配单位

页面到页帧：逻辑地址到物理地址的转换，通过页表

![image-20230214201822687](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201822687.png)

![image-20230214201837448](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201837448.png)

![image-20230214201903421](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201903421.png)

![image-20230214201918157](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214201918157.png)

页式存储管理机制的性能问题

![image-20230214202004536](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214202004536.png)

快表：增加硬件—转换检查缓冲区（TLB）,速度远快于内存，用于存储少量页表项的相关信息

![image-20230214202226795](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214202226795.png)

**多级页表**

![image-20230214202352895](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214202352895.png)

![image-20230214202422153](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214202422153.png)

![image-20230214202525943](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214202525943.png)

**倒排页面**：为每个页框间建一个表项，记录某个进程虚拟页面定位于该页框

![image-20230214203400310](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214203400310.png)

为了提高倒排页面的搜索速度，建立散列表

![image-20230214203450225](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214203450225.png)

- 访问的页面不在内存时，引起缺页中断
- 页面发生缺页中断而无空闲页框时，必须**选择**一个页面换换出（**页面置换**），为即将掉入内存的页面腾出空间

![image-20230214203943840](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214203943840.png)

置换算法的功能

当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面

设计目标：

- 尽可能减少页面的调入调出次数
- 把未来不再访问或短期内不访问的页面调出

置换算法的评价方法：

- 模拟页面置换行为，记录产生缺页的次数
- 更少的缺页，更好的性能

![image-20230214204550090](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214204550090.png)

**最优页面算法（OPT）**

置换在未来最长时间不访问的页面

**算法实现**：

缺页时，计算内存中每个逻辑页面的下一次访问时间，选择**未来最长时间不访问的页面**

特点：理想情况，无法实现

**先进先出算法（FIFO）**

选择**在内存驻留时间最长**的页面进行置换

![image-20230214205608851](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214205608851.png)

**最久未使用算法（LRU）**

![image-20230214205652478](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214205652478.png)

**时钟置换算法（Clock）**

![image-20230214205847783](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214205847783.png)

![image-20230214210156722](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214210156722.png)

**第二次机会页面置换算法（SCR）**

![image-20230214210413214](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214210413214.png)

**改进后的Clock算法**

在页面中增加修改位，并在访问时进行相应修改

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214210932263.png" alt="image-20230214210932263" style="zoom:150%;" />

**Belady现象**

现象：采用FIFO等算法时，可能出现分配物理页面数增加，缺页次数反而升高的异常现象

原因：被FIFO置换出去的页面不一定是进程近期不会访问的

**全局置换算法**

全局置换算法为进程分配**可变数目**的物理页面

全局置换算法要解决的问题

- 进程在不同阶段的内存需求是变化的
- 分配给进程的内存也需要在不同阶段有所变化
- 全局置换算法需要确定分配给进程的物理页面数

![image-20230214212402101](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214212402101.png)

![image-20230214212417080](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230214212417080.png)

**工作集置换算法**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215091446488.png" alt="image-20230215091446488" style="zoom:67%;" />

**工作集时钟页面算法**

对工作集页面置换算法和时钟页面置换算法的综合

思想：需缺页置换时，检查指针指向的页面

- 如果R=1,则置R=0,指针下移
- 如果R=0，M=0且生存时间>T则淘汰该页
- 否则，指针继续下移

缺页率：缺页次数/内存访问次数

影响缺页率的因素：

- 页面置换算法
- 分配给进程的物理页面的数目
- 页面大小
- 程序的编写方法

**缺页率置换算法（PFF）**

常驻集：在当前时刻，进程实际驻留在内存当中的页面集合

通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内

- 若缺页率高，增加常驻集
- 缺页率低，减少常驻集

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215092857856.png" alt="image-20230215092857856" style="zoom:67%;" />

**抖动问题**

抖动：

- 进程物理页面太少，不能包含工作集
- 造成大量缺页，频繁置换
- 进程运行速度变慢

产生抖动的原因：

随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减少，缺页率不断上升

操作系统需要在并发水平和缺页率之间达到一个平衡：

选择一个适当的进程数目和进程需要的物理页面数

**负载控制**

通过调节**并发进程数（MPL）**来进行系统负载控制

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215093545594.png" alt="image-20230215093545594" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215093601488.png" alt="image-20230215093601488" style="zoom:67%;" />

**分页设计问题**

**调页策略**

请求调页：进程运行中发生了缺页，每次仅调入一页，系统开销大，增加了磁盘I/O启动的频率，易实现，常用

预先调页：通常用于首次掉入内存时，预先调入若干个预计在不久后将执行的页面，预测不准：约50%

分页缺点：虚地址空间是一维的，不利动态增长

解决：根据逻辑关系分段

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215100246743.png" alt="image-20230215100246743" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215100318344.png" alt="image-20230215100318344" style="zoom:67%;" />

**段与页的区别**

- 页是信息的物理单位，段是信息的逻辑单位；分页是系统管理的需要，分段是用户的需要
- 页的大小固定，由系统确定；段的大小动态变化，决定与用户编程的需要
- 分页是一维的，分段是二维的
- 分页不容易实现共享和动态链接，分段很容易实现

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215100644399.png" alt="image-20230215100644399" style="zoom:67%;" />

段式存储在内存保护有优势，页式存储在内存利用和优化转移到后备存储方面有优势

**段页式存储管理**

结合分页分段的优势

段表结构：段号、段内页号，页内偏移量

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215100941984.png" alt="image-20230215100941984" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230215101237893.png" alt="image-20230215101237893" style="zoom:67%;" />

**第五章 文件系统**

进程：进程是一个正在执行的程序

进程地址空间：一个进程用于寻址内存的一套地址集合

**文件：文件是进程创建的信息逻辑单元**

处理文件的操作系统部分称为文件系统

引入文件的原因：

- 能够保存大容量数据
- 进程终止时，信息依旧存在
- 信息和进程独立，多进程能够并发访问信息

文件：

- 文件是进程创建的信息逻辑单元
- 文件是磁盘的一种地址空间

文件系统：文件是由操作系统管理的，把操作系统中处理文件的部分称为文件系统

文件系统功能：

- 分配文件磁盘空间
- 管理文件集合
- 数据可靠和安全

文件结构通常有三种：字节序列、记录序列、树

魔数：很多类型的文件，其起始的几个字节的内容是固定的（这几个字节的内容就称为魔数，因为根据这几个字节内容就可以确定文件类型）

BSS：以符号开始的块，BSS是Unix链接器产生的未初始化数据段。其他的段分别包含程序代码的“text”段和包含已初始化数据的“data"段。BSS段的变量只有名称没有值

操作系统中进程访问文件的模式：

- 顺序访问：按字节依次读取
- 随机访问：从中间读写
- 索引访问：依据数据特征索引

文件除了文件名和数据外，还会保存其他与文件相关的信息，这些附加信息称为文件属性，或元数据

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216092745046.png" alt="image-20230216092745046" style="zoom:67%;" />

为了记录文件信息，文件系统通常有目录或文件夹。在许多系统中，目录本身就是文件

**目录项：**

- 目录的基本组成元素，又称为文件控制块（FCB）
- 内容：存放了管理文件所需要的所有有关信息，包含了文件名、存储地址等基本信息以及**存取控制信息**和**使用信息**
- 目录项是文件存在的标志：目录项与文件一一对应

**文件目录（目录）：**

目录项的有序集合

**目录文件：**

实现对文件目录的管理，通常将文件目录以文件的形式保存在外存，这个文件就是目录文件

**目录结构：**

文件系统中所有目录间的关系

操作系统只允许内核修改目录：为了确保映射的完整性、应用程序通过系统调用访问目录

[硬链接和软连接]: https://www.jianshu.com/p/dde6a01c4094

文件链接的循环

如何保证没有循环？

- 只允许到文件的链接，不允许在子目录的链接
- 增加链接时，用循环检测算法确定是否合理

![image-20230216183247585](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216183247585.png)

**文件分配**

如何表示分配给一个文件数据块的位置和顺序？

分配的方式：连续分配、链式分配、索引分配

**连续分配**

文件头指定起始块和长度

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216184806083.png" alt="image-20230216184806083" style="zoom:67%;" />

**链式分配**

为了消除连续分配外部碎片问题

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216185331232.png" alt="image-20230216185331232" style="zoom:80%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216185408598.png" alt="image-20230216185408598" style="zoom:67%;" />

改进链式存储—以蔟为单位进行分配，一簇可包含多个盘块；链接文件以蔟为单位，这样成倍的减少指针占用的存储空间，也成倍的减少查找指定块的时间

好处：

- 减少指针占用空间
- 提高检索速度

隐式链接：磁盘块存储文件和指针，直接通过链表串起来

显式链接：一个盘块内记录了很多指针（这个表称为文件分配表FAT）

- 簇/块 是操作系统读写文件的基本单位。
- 磁盘读写基本单位是扇区。操作系统是通过块和簇来做为单位读取等操作数据的。
- 扇区是磁盘最小的物理存储单元，是磁头从磁盘中读取数据的最小单位

 **扇区是对硬盘而言，是物理层的。** **块和簇是对文件系统而言，是逻辑层的。磁盘控制器是用来映射两层的**

**索引分配**

当FAT表很多时，直接降低了存取效率，这个问题的根源是因为需要把所有FAT表调入内存

解决思想：访问某文件时，只调入该文件所占用的盘快对应的编号

解决办法：将每个文件所对应的盘块编号集中放在一个盘块中，该盘块叫索引块

![image-20230216192606429](/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216192606429.png)

新问题：

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216211909803.png" alt="image-20230216211909803" style="zoom:50%;" />

进程访问文件数据前必须打开文件

内核追踪进程打开的所有文件

- 操作系统为每个进程维护一个打开文件表
- 文件描述符是打开文件的标识

文件描述符：操作系统在打开文件表中维护的打开文件状态和信息

- 文件指针（最近一次读写位置）
- 文件打开计数
- 文件的磁盘位置（缓存数据访问信息）
- 访问权限

**文件的用户视角和系统视角**

**文件的用户视角**：持久的数据结构

**操作系统的文件视角**：数据块的集合

数据块按需读入内存，数据块使用后被缓存

两种数据块缓存方式：数据块缓存、页缓存（统一缓存数据块和内存页）

页缓存

[https://cloud.tencent.com/developer/article/1848933]: 

**文件共享和访问控制**

多用户系统中文件共享是很有必要的

访问控制：

每个用户能够获得哪些文件的访问权限

访问模式：读、写、执行、删除等

文件访问控制列表(ACL)      <文件实体，权限>

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216225547841.png" alt="image-20230216225547841" style="zoom:50%;" />

**磁盘空间管理**

盘块是磁盘空间分配的基本单位，磁盘空间管理就是对盘块的管理

磁盘访问时间=寻道时间+旋转延迟时间+传输时间

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216230258432.png" alt="image-20230216230258432" style="zoom:50%;" />

**空闲空间组织**

**位图**

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216230737516.png" alt="image-20230216230737516" style="zoom:50%;" />

**盘块链表**：把空闲盘块号集中存储在某些空闲盘块中

**讨论**

- 通常，位图比盘块链表更节省空间，除非磁盘空闲盘块数极少
- 对倾向于连续空闲盘块多的磁盘，可改进盘块链表节约空间，以记录连续空闲盘块区的方式链接
- 位图法的盘块分配与回收

分配：顺序扫描位示图，找到0，将找到的二进制位转化成相应的盘块号，修改位示图

回收：将回收盘块的盘块号转换成位示图中的行号和列号，修改位示图

磁盘配额：多用户操作系统防止用户占有太多磁盘空间，提供一种强制性磁盘配额机制

**文件系统的可靠性**

- 文件系统备份
- 文件系统一致性检查：如果系统崩溃后没有全部写会会导致不一致

**文件系统备份**

物理转储：将全部磁盘盘块按序输出到备份磁带上，属于全量转储

逻辑转储：从一个或几个指定的目录开始，递归的转储其给定基准日期后已更改的全部文件和目录，属于增量转储

**文件系统的一致性**

盘块修改后由于系统崩溃没有全部写回会导致不一致

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216232452201.png" alt="image-20230216232452201" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216233411978.png" alt="image-20230216233411978" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216233440179.png" alt="image-20230216233440179" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216233520212.png" alt="image-20230216233520212" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216233639816.png" alt="image-20230216233639816" style="zoom:50%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216233758465.png" alt="image-20230216233758465" style="zoom:50%;" />

文件系统性能

与访问内存相比，访问磁盘的速度慢百万数量级

改善性能的常见措施：

高速缓存、块提前读、减少磁臂运动

块提前读：在需要使用块之前快速写入高速缓存

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230216234206056.png" alt="image-20230216234206056" style="zoom:50%;" />

**第六章 输入输出**

通常输入输出类设备都是字符设备，而存储类设备都是块设备

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230217092808776.png" alt="image-20230217092808776" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230217093001315.png" alt="image-20230217093001315" style="zoom:67%;" />

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230217093051309.png" alt="image-20230217093051309" style="zoom:67%;" />

CPU与设备通信的方式：轮询、设备中断、DMA

**CPU主动轮询：**

- I/O设备在特定的**状态寄存器**中放置状态和错误信息
- 操作系统**定期检测**状态寄存器
- 特点：简单、I/O操作频繁或不可预测时，开销大和延时长

<img src="/Users/lijiayan/Library/Application Support/typora-user-images/image-20230217093512233.png" alt="image-20230217093512233" style="zoom:67%;" />

独立的I/O地址空间

内存映射I/O ：通过比较范围区分访问内存空间还是I/O空间

混合模式：控制寄存器具有单独的I/O端口，数据缓冲区映射到内存空间

CPU与设备控制器交换数据以字节为单位浪费时间，解决办法：直接存储器存取（DMA）



















