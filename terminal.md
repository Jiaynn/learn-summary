### 前端工程化

**定义**：在规模化前端项目开发的场景下，利用标准化、可衡量的工具、流程和系统，提升效率、质量，降低前端的研发成本，服务好企业与前端开发者的需求

![](D:\Web\自己总结的学习记录\md图片\engineering.png)

 **前端项目的研发流程**

![](D:\Web\自己总结的学习记录\md图片\dev.png)

本地研发工具

![](D:\Web\自己总结的学习记录\md图片\qianduangongcheng.png)

本地研发套件/接口

本地研发工具松散的结构转化成一个框架团队方案，开发者无论开发哪种项目，看起来使用的该工具都是同一个==》DEF CLI

不同的研发模式我只需要封装一个解决方案，它只需要实现def规定的一个接口，就可以在def生态中实现初始化，构建器预览测试的一个统一以及规范化

![](D:\Web\自己总结的学习记录\md图片\texst.png)

一般情况下我们发布产品会选择两个环境，一个供内部人员测试，还有一个面向用户，它对应两个不同的url，如果我们想只使用有一个url应该怎么作呢？

我们就可以选择**灰度发布**

在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。

![](D:\Web\自己总结的学习记录\md图片\bushu.png)

npm安装包是一个动态版本机制，就是我们在不同的时间安装包他的版本可能不一样

**使用semver**

功能包括：

- 比较两个版本号的大小
- 验证某个版本号是否合法
- 提取版本号，例如从“=v1.2.1”体取出"1.2.1"
- 分析版本号是否属于某个范围或符合一系列条件

**解决依赖问题的四个步骤**

感知 锁定 部分升级 黑名单

感知—真实依赖版本记录与对比

让开发者清晰的了解自己在构建时使用的依赖的版本以及在不同发布间版本的变化

依赖反查

离线计算：预处理package.json中的依赖树，每小时批量处理上一个小时的线上构建的依赖树，把应用依赖树中的每一个依赖都生成一条对应的依赖到应用的一个记录，同时记录依赖版本以及依赖的一个路径 ，在之后我们想查询某个依赖影响的应用范围时，直接查依赖到应用的表就可以了

依赖锁定

保存安装时的所有依赖以及依赖的一个实际版本，供下次安装时读取

依赖部分升级能力与依赖黑名单

![](D:\Web\自己总结的学习记录\md图片\lock.png)

依赖锁定后，我们只想让ice.js的依赖升级应该怎么做

我们可以先维护一份内部需要在依赖锁定后仍需要**自动升级**的包的列表

但这一般在日常环境中做，线上环境使用的还是日常环境锁

在自动线上发布的时候，使用日常发布时更新的锁文件来进行以来的安装

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-21_18-16-55.png)

前端工程源站

CDN与源站

源站：托管前端项目构建后生成的产物，如html、js、css等资源的服务

CDN：内容分发网络，即建立并覆盖在承载网之上，由遍布全球的边缘节点服务器组成的分布式网络

边缘程序（EdgeRoutine，简称ER）和灰度

ER边缘计算是一个新的领域，客户可以在边缘的节点上开出一些虚拟机容器

传统的CDN就是在距离客户端更近的CDN节点上，把缓存文件分发给客户端，这些缓存都是静态的

CDN+ER：可以缓存一些动态的逻辑，可以JavaScript直接部署到ER上面去

ER的具体实践：灰度和多版本模式的源站

之前说到的灰度发布，他的逻辑其实是做到源站上的，利用ER后，我们就可以把灰度的这个逻辑直接下发到边缘的节点上面，去进行一个计算，判断用户属于哪一个灰度级，然后给用户返回对应的资源

#### 小程序

#### 小程序的基本构成

**文件类型：**

AXML：主要用于描述小程序的UI的，使用标记语言，在小程序中的作用类似于剔除了js逻辑跟css内容的html文件

AXML语法可分为五个部分：数据绑定、条件渲染、列表渲染、模板、引用

JavaScript：小程序的js文件内是无法调用DOM、BOM API

ACSS：样式

JSON： APP、Page等的配置文件

**业务结构：**

一个小程序基本由APP、Page、Component

#### 主流的构建工具

> Webpack
>
> Rollup：主要强调对库开发的支持，基于ESM模块系统，对tree shaking 有良好的支持
>
> ESBuild：使用go语言开发的构建工具，编译速度快

小部件是小程序的子类型，他是可以脱离宿主来存在类似于小程序的插件

小部件构建的需求分析

多文件：打包为一个文件

安全限制：禁止开发者调用到底层的端能力

能力调用：产物是无法单独运行的，我们需要调用框架相关能力去做一些渲染能力

#### 小程序 运行时

双线程模型：为什么会使用双线程模型？

我们在h5上面开发时，容易遇到运行时卡顿的问题，因为js的执行和页面的渲染他是处于竞争关系，所以小程序从底层机制上去解决问题，所以就设计了双线程模型

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_10-52-24.png)

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_10-56-56.png)

 **双线程模型带来的好处**

- 数据驱动：微信小程序不可以使用js直接控制界面元素，而是通过改变 this.data中的属性,同步到界面，这个问题可以克服,带来的就是和H5不一样的编码方式.JS中更多的是改变数据的逻辑,而不是获取某个View来改变属性值，数据层和ui层完全解耦，解耦开了的好处就是我的ui层可以动态更新

- 高性能：避免了js线程和渲染线程竞争导致卡顿，渲染引擎和逻辑引擎解耦，可各自进行演进优化

-  安全机制：避免了开发者直接操作DOM

#### 小程序启动流程

点击小程序的icon，接下来这个流程运转到容器层，我们的app层面，app会收到小程序的ide，然后查询本地小程序的资源是否被下载过，下载过了就直接打开，没有下载过，会去看线上这个app对应的小程序最新的版本是什么，然后把这个对应版本的资源下载到本地，然后再去解压

存在几种特殊情况：

如果本地完全没有资源，那么第一次打开小程序会比较慢，因为他回去查询有没有这个小程序，这个小程序的版本号，然后走网络请求，把小程序的资源下载下来，再解压再打开

如果本地有资源，但小程序有版本的概念，如果本地的小程序查询到的版本号是旧版本，就面临一个问题：到底是等最新的版本下载下来再打开还是直接打开现在的版本

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_12-07-59.png)

当我们把离线包下载下来之后，再解压后，主要会有两个文件

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_12-08-28.png)

对于实现App Page Component等全局符号：因为我们在小程序中是直接那page component去使用，没有import,require等导入行为，这些全局的符号就是有框架提供的

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_12-20-47.png)

**页面渲染**

首页渲染：首先对于render来讲，他会触发initMessageChannel,他告诉native说我现在要进行通信了，你需要帮我建立一条render和worker的通信链路，当native把Channel建立好后，render会触发postMessage,把当前我要渲染的小程序页面的地址发给worker，通过Channel进行通信，需要把postMessage所带的数据进行序列化和反序列化，然后通知到worker

worker触发完onshow后，会告诉render,我要开始渲染初始化，他初始化渲染的数据是什么样子呢，就会把这份数据发给render,这份数据来自于我在写配置的时候，我们可以去设置page的data的，把这份data通过channel传递给render

render拿到这份数据就开始第一次渲染，渲染完后，就会告诉worker渲染完毕，然后worker触发onready事件

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_12-27-33.png)

 这个时候首页就渲染出来了，用户就会在页面上进行一些交互的操作

**事件触发**

加入用户点击了页面上的按钮，我怎么从render通知到worker

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_12-58-18.png)

JSAPI

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_13-02-21.png)

**如何开发高性能的小程序？**

启动

分包：会把我自己写的代码直接在容器里面去运行，当页面有100个的时候和页面有10个的时候，代码运行的量是不一样的，如果一个小程序业务特别复杂，页面特别多的时候，我们可以用小程序分包的这种方式，去把他关键的主要首屏展示的页面，放在一个主包里面，有些不是常常可以访问到的，我们就可以放到另外的小程序的包里面去

快照：小程序刚开始进去的时候，页面的那套流程，在后台运行，然后ui直接先盖上去一个之前小程序展示了什么样，先有一个类似于图片的东西盖上去或者先把首屏的结构先保存下来

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-23_13-56-01.png)



### 3D引擎技术原理与实践

#### 什么是图形学？

 是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学

通俗的讲，就是把数字的一些数据生成图像的学科

图片放大是由一个个像素组成，每个像素有三个发光二极管组成（rgb）,所以图形学的学科就是如何去计算每一个像素的rgb的值，这个过程就叫做渲染

渲染本质上就是模拟整个光照在场景里的一个传播 的过程

比如我们人眼看到一张图片，我们计算图像的rgb值，他的计算就是把整个光线在那个场景里传播之后，经过一个复杂的计算，算出最终的一个颜色的的值，这个就叫渲染

#### 3D渲染基础

 渲染是一个计算过程，计算就需要输入，首先我们得有渲染数据，渲染数据主要有三个要素：模型、材质、光照

 **实时渲染：**模拟照相机把整个物体通过投射的方式 投影到整个屏幕上，他是可交互的

实时渲染原理：主要借助了显卡GPU的一个能力，通过将顶点信息或者三角形的index传进去，在gpu上有一个vertex shader，把他组装成一个三角形片源之后，进入一个光栅化阶段，**光栅化**的意思是说三角形覆盖了整个图片的哪些像素，圈出来之后会进入pixel shader ,就是光栅化后，我们要计算每一个像素的颜色，所以他会把贴图的材质信息全部就计算出来，最终形成一张二维的图片

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923165204.png)

**离线渲染：**模拟真实的整个光线他在整个场景中的运动—真实但非常慢

**路径跟踪法：**它通过人眼看到像素，通过人眼发射很多光线的方式穿过像素来追踪他在每一个场景里通过每一个物体然后打到墙上，在打到光源上，通过反向计算的方式去收集这条路径上所有的光照信息，最终汇集到每个像素，把每个像素最终的颜色值计算出来

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923165228.png)

#### 实时渲染引擎

什么是渲染引擎？

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923171358.png)



![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923172509.png)

从管线角度讲，我们需要先执行一个vertex shader(一个自定义的程序，把输入这个世界的Geometry数据，转换到一个屏幕空间)

渲染效果

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923173902.png)

**光线追踪技术原理**

ray tracing（光线跟踪）

第一次提出用光线追踪来解决渲染问题，从摄像机发射光线，然后光线在3D场景中游走，可能撞到了物体，也有可能产生了shadow,也有可能撞过物体经过反射撞到了光源，然后就算出来光照

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923185540.png)

path tracing

1986年提出了渲染方程的概念，空间里任何一点的光照等于这点的自发光加上这一点根据材质模型和灯光模型所计算出来的光照的信息

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923185549.png)

Subsurface scattering(次表面散射)

Path tracing of volumes(体渲染)

光线在空间里游走，他按照步长做了一个光照计算的一个积分，那么所谓的光线在一个体渲染的体数据里面游走，他会碰到光，我的光线有可能被吸收，有可能遇到自发光

bidirectional path tracing(双向路径追踪)

从照相机和光源的角度同时向场景中去发射光线，然后把两种方向的光线连接起来，这样就能计算出每一个路径的能量，整个路径的能量最后反映到最后那张照片上

双向路径的好处：他可能解决像高光 焦散的这种现象，他比单向的路径更加收敛

![](D:\Web\自己总结的学习记录\md图片\QQ截图20220923190831.png)

photon mapping(光子映射)

我们从光源的角度向3D的场景去发射光子，整个光子就布满了整个3D空间，然后再从照相机的角度去发射光线，那么所有的光线在3D场景中撞到的地方



### 编译原理

什么是编译？

one language to another

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-24_11-55-12.png)

A. 源码到源码—typescript==》javascript

B.源码到字节码—javascript

C.源码到机器码—C/C++等编译语言

D.字节码到机器码—Just-In-Time Compiler

**编译技术的层次结构**

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-24_12-04-06.png)

front end 指一些语言的输入，他的输入我们会进行一些初期的处理（转换为一个token流、转换为AST)

middle end进行了前期处理后，我们把它放入优化器里面进行优化

back end 经过优化之后，back end会把他们产生到各自的一个目标产物上

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-24_12-08-08.png)

转化为AST后，假设是一个编译执行的语言，大概率会转会成IR

![ ](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-24_12-12-01.png)

![](D:\Web\自己总结的学习记录\md图片\Snipaste_2022-09-24_12-30-37.png)

 









